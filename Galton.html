<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galton Board with Sequential Release</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            font-family: 'Arial', sans-serif;
            background-color: #f0f4f8;
            color: #333;
        }
        h1 {
            margin-bottom: 20px;
            font-size: 2.5rem;
        }
        canvas {
            display: block;
            margin-bottom: 20px;
            background-color: black;
            border-radius: 10px;
            border: 2px solid #444;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        button {
            background-color: #28a745;
            border: none;
            padding: 15px 30px;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #218838;
        }
        button:active {
            background-color: #1e7e34;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        #description {
            
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: left;
            margin: 20px;
        }

        #description h2, #description h3 {
            color: #2c3e50;
        }

        #description ul {
            margin: 10px 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div id="description">
        <h1>Гальтон тақтасы</h1>
 <p>Гальтон тақтасы – кездейсоқ процестерді және үлкен сандар заңын көрсетуге арналған құрылғы. Ол сондай-ақ пинбол немесе пинбол тақтасы ретінде белгілі. Құрылғының мәні мынада: тікенектер немесе ілгектер қатары арқылы құлаған шарлар кездейсоқ ауытқиды, егер шарлар саны жеткілікті үлкен болса, қалыпты (гаусс) үлестірімге жақындайтын үлестірімді құрайды.</p>

 <h2>Гальтон тақтасының жұмыс істеу принципі</h2>
 <h3>Дизайн:</h3>
 <p>Тақта торда орналасқан көптеген көлбеу ұштары бар тік панельден тұрады. Тақтаның жоғарғы жағында шарлар түсірілетін тесік бар.</p>

 <h3>Шарлар:</h3>
 <p>Шұңқырдан құлаған шарлар төмен түсіп бара жатқанда шыбықтармен соқтығысады. Доп төбеге тиген сайын белгілі бір ықтималдықпен солға немесе оңға ауытқиды.</p>

 <h3>Траектория:</h3>
 <p>Шыбықпен соқтығысқан сайын доптың траекториясы кездейсоқ өзгереді. Әрбір қадамда оның ауытқуы солға да, оңға да болуы мүмкін және әр деңгейде алдыңғы соқтығыстарға байланысты. Осы кездейсоқ процестің нәтижесінде доп төмен қарай жол тауып, соңында тақтаның төменгі жағындағы шаршылардың біріне түседі.</p>

 <h3>Тарату:</h3>
 <p>Тақтаның жоғарғы жағынан көптеген шарлар түсірілгенде, олар тақтаның төменгі жағындағы әртүрлі бөліктерге түседі. Шарлар саны артқан сайын, егер шыбықтар кездейсоқ орналасса және әр деңгейде ауытқу ықтималдығы бірдей болса, қалыпты таралуға (қоңырау тәрізді) жақындайтын үлестірім пайда болады.</p>

 <h2>Математикалық мағына</h2>
 <p>Гальтон тақтасы - үлкен сандар заңының және орталық шек теоремасының физикалық иллюстрациясы. Орталық шек теоремасының мәні мынада: егер процесте тәуелсіз кездейсоқ оқиғалардың көп саны пайда болса, онда бұл оқиғалардың қосындысы (мысалы, доптың вертикальдан ауытқуы) қалыпты заңға қарамастан таралады. жеке оқиғалардың таралу пішінінің.</p>

 <h3>Үлкен сандар заңы:</h3>
 <p>Доптар неғұрлым көп болса, соғұрлым тақтаның төменгі жағындағы бөлу біркелкі болады. Бұл кездейсоқ процестер ұзақ мерзімді перспективада тұрақты және болжамды нәтижелерге қалай әкелетінін көрсетеді.</p>

 <h3>Орталық шек теоремасы:</h3>
 <p>Әрбір шардың ауытқулары тәуелсіз және кездейсоқ болуы мүмкін болса да, олардың тақтадағы соңғы орындарының таралуы статистика мен ықтималдық процестердің негізі болып табылатын қалыпты үлестірімге сәйкес болады.</p>

 <h2>Қолданба</h2>
 <ul>
 <li><b>Статистика түсіндірілді:</b> Гальтон тақтасы жиі кездейсоқтық, статистика және ықтималдықтар теориясының принциптерін түсіндіру үшін оқу орындарында көрнекі құрал ретінде пайдаланылады.</li>
 <li><b>Кездейсоқ процестерді көрсету:</b> Бұл көптеген жүйелер нақты өмірде, мысалы, биологияда, экономикада, физикада және басқа салаларда кездесетін кездейсоқ процестердің айқын мысалы бола алады.</li>
 </ul>

 <p>Гальтонның тақтасы — бейберекеттіктен үлгінің қалай пайда болатынын көрсететін кездейсоқтық пен тәртіптің тамаша көрінісі.</p>
    </div>
<div class="container">
    <h1>Galton Board Simulation</h1>
    <canvas id="galtonCanvas" width="950" height="750"></canvas>
    <div class="controls">
        <button id="startButton">Start</button>
        <button id="resetButton" disabled>Reset</button>
    </div>
</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        const { Engine, Render, Runner, World, Bodies, Body, Events } = Matter;

        const WIDTH = 950;
        const HEIGHT = 850;
        const BALL_RADIUS = 7;
        const PEG_RADIUS = 10;
        const ROWS = 9;
        const COLS = 16;
        const PEG_SPACING = 56;
        const GRAVITY = 1;

        const engine = Engine.create();
        engine.world.gravity.y = 0; 
        const world = engine.world;

        const canvas = document.getElementById('galtonCanvas');
        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: WIDTH,
                height: HEIGHT,
                wireframes: false,
                background: 'black',
            },
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        function createPeg(x, y) {
            const peg = Bodies.circle(x, y, PEG_RADIUS, {
                isStatic: true,
                render: { fillStyle: 'darkslateblue' },
            });
            World.add(world, peg);
        }

        for (let row = 0; row < ROWS; row++) {
            const offsetX = row % 2 === 0 ? PEG_SPACING / 2 : 0;
            for (let col = 0; col < COLS; col++) {
                const x = offsetX + col * PEG_SPACING + 50;
                const y = 150 + row * PEG_SPACING * 0.8;
                createPeg(x, y);
            }
        }

        const binWidth = WIDTH / COLS;
        for (let i = 0; i <= COLS; i++) {
            const x = i * binWidth;
            const wall = Bodies.rectangle(x, HEIGHT - 50, 10, 300, {
                isStatic: true,
                render: { fillStyle: 'darkolivegreen' },
            });
            World.add(world, wall);
        }

        const ground = Bodies.rectangle(WIDTH / 2, HEIGHT, WIDTH, 20, {
            isStatic: true,
            render: { fillStyle: 'darkslategray' },
        });
        World.add(world, ground);

        const funnelLeft = Bodies.rectangle(WIDTH / 2 - 208, 30, 400, 20, {
            isStatic: true,
            angle: Math.PI / 8,
            render: { fillStyle: 'darkred' },
        });
        const funnelRight = Bodies.rectangle(WIDTH / 2 + 197, 30, 400, 20, {
            isStatic: true,
            angle: -Math.PI / 8,
            render: { fillStyle: 'darkred' },
        });
        World.add(world, [funnelLeft, funnelRight]);

        const balls = [];

        function startRelease() {
            for (let i = 0; i < 300; i++) {
                const ball = Bodies.circle(
                    WIDTH / 2,  
                    Math.random() * 40 + 10,  
                    BALL_RADIUS,
                    {
                        restitution: 0.5,
                        friction: 0.1,
                        render: { fillStyle: 'white' },
                    }
                );
                World.add(world, ball);  
                balls.push(ball);
            }
            engine.world.gravity.y = GRAVITY; 
            document.getElementById('resetButton').disabled = false;
        }

        document.getElementById('startButton').addEventListener('click', () => {
            startRelease();
        });

        document.getElementById('resetButton').addEventListener('click', () => {
            World.clear(world); 
            balls.length = 0; 
            engine.world.gravity.y = 0; 
            World.add(world, [funnelLeft, funnelRight, ground]); 

            for (let row = 0; row < ROWS; row++) {
                const offsetX = row % 2 === 0 ? PEG_SPACING / 2 : 0;
                for (let col = 0; col < COLS; col++) {
                    const x = offsetX + col * PEG_SPACING + 50;
                    const y = 150 + row * PEG_SPACING * 0.8;
                    createPeg(x, y);
                }
            }
            for (let i = 0; i <= COLS; i++) {
                const x = i * binWidth;
                const wall = Bodies.rectangle(x, HEIGHT - 50, 10, 300, {
                    isStatic: true,
                    render: { fillStyle: 'darkolivegreen' },
                });
                World.add(world, wall);
            }
            document.getElementById('resetButton').disabled = true;
        });
    </script>
</body>
</html>
